# agents/insight_generator.py
import pandas as pd
import numpy as np
import logging
import os
from datetime import datetime

from models.anomaly_detector import AnomalyDetector
from models.budget_recommender import BudgetRecommender

# ---------------- Setup ---------------- #
os.makedirs("logs", exist_ok=True)
logging.basicConfig(
    filename="logs/insight_generator.log",
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)

DATA_PATH = "data/finance_test.csv"
MODEL_DIR = "models/"


class InsightGeneratorAgent:
    """
    Insight generator for UNIQUE value:
      - Summary stats
      - Anomalies (with explanations)
      - Trend detection
      - Forecasting
      - Goal tracking
      - Personalized alerts
      - Responsible AI checks
    """

    def __init__(self, df=None, savings_target: float = 5000):
        if df is None:
            try:
                self.df = pd.read_csv(DATA_PATH)
            except Exception:
                self.df = pd.DataFrame()
        else:
            if hasattr(df, "get_transactions_df") and callable(df.get_transactions_df):
                try:
                    self.df = df.get_transactions_df()
                except Exception:
                    self.df = pd.DataFrame()
            elif isinstance(df, pd.DataFrame):
                self.df = df.copy()
            else:
                try:
                    self.df = pd.DataFrame(df)
                except Exception:
                    self.df = pd.DataFrame()

        self.anomaly_det = AnomalyDetector(os.path.join(MODEL_DIR, "anomaly_detector.pkl"))
        self.budget_rec = BudgetRecommender(os.path.join(MODEL_DIR, "budget_recommender.pkl"))

        self.savings_target = savings_target

    # ---------------- Responsible AI ---------------- #
    def responsible_ai_checks(self):
        issues = []

        if self.df is None or self.df.empty:
            return ["‚ö†Ô∏è No data available for Responsible AI checks."]

        # Category balance
        if "category" in self.df.columns:
            category_counts = self.df["category"].value_counts(normalize=True)
            if not category_counts.empty and category_counts.min() < 0.05:
                issues.append("‚ö†Ô∏è Some categories are underrepresented (<5%) ‚Üí possible bias.")
            else:
                issues.append("‚úÖ Category distribution looks balanced.")

        # Transparency sample
        try:
            sample = self.df.sample(min(3, len(self.df)))
            logging.info("Transparency sample logged:")
            for _, row in sample.iterrows():
                logging.info(row.to_dict())
            issues.append("‚úÖ Transparency: sample rows logged.")
        except Exception as e:
            logging.warning(f"Transparency check failed: {e}")
            issues.append("‚ö†Ô∏è Transparency check failed.")

        # Sensitive data
        sensitive_cols = [c for c in self.df.columns if "name" in c.lower() or "account" in c.lower()]
        if sensitive_cols:
            issues.append(f"‚ö†Ô∏è Sensitive columns detected: {sensitive_cols}. Consider anonymization.")
        else:
            issues.append("‚úÖ No sensitive columns detected.")

        return issues

    # ---------------- Basic Insights ---------------- #
    def summary_stats(self):
        if self.df is None or self.df.empty:
            return {}

        total_income = self.df[self.df["type"] == "income"]["amount"].sum()
        total_expense = self.df[self.df["type"] == "expense"]["amount"].sum()
        savings = total_income - total_expense
        savings_rate = (savings / total_income * 100) if total_income > 0 else 0

        return {
            "Total Income": round(total_income, 2),
            "Total Expense": round(total_expense, 2),
            "Savings": round(total_income - total_expense, 2)
        }

    def generate_insights(self, df):
        if df is None or df.empty:
            return ["No data available."]

        insights = []

        # Income vs Expense check
        income = df[df["type"] == "income"]["amount"].sum()
        expense = df[df["type"] == "expense"]["amount"].sum()
        if expense > income:
            insights.append("‚ö† You spent more than you earned.")
            insights.append("[Explainability] This insight is generated by comparing total expenses and income. Spending exceeded earnings.")
        else:
            insights.append("‚úÖ You saved money overall.")
            insights.append("[Explainability] This insight is generated by comparing total expenses and income. You saved money.")

        # Expense prediction
        try:
            last_date = pd.to_datetime(df["date"]).max()
            next_month = (last_date.month % 12) + 1
            next_year = last_date.year + (1 if last_date.month == 12 else 0)
            pred = self.expense_predictor.predict_next_month(next_month, next_year)
            insights.append(f"üìÖ Predicted expenses for {next_month}/{next_year}: ${pred:.2f}")
            insights.append(f"[Explainability] This prediction uses a linear regression model trained on past monthly expenses.")
        except Exception:
            insights.append("‚ö† Prediction unavailable.")
            insights.append("[Explainability] Prediction failed due to missing or invalid data.")

        # Anomaly detection
        try:
            anomalies = self.anomaly_det.detect(self.df)
            if not anomalies.empty:
                a = anomalies.iloc[-1]
                insights.append(f"üö® Anomaly: {a['category']} - ${a['amount']:.2f} on {a['date']}")
                insights.append(f"[Explainability] This anomaly was detected using Isolation Forest on expense amounts.")
        except Exception:
            insights.append("‚ö† Anomaly detection unavailable.")
            insights.append("[Explainability] Anomaly detection failed due to missing or invalid data.")

        # Category classifier
        try:
            if "note" in df.columns and not df["note"].dropna().empty:
                note = df["note"].dropna().iloc[-1]
                pred_cat = self.category_classifier.predict(note)
                insights.append(f"üìù Last note '{note}' classified as '{pred_cat}'")
                insights.append(f"[Explainability] This classification uses a Naive Bayes model trained on transaction notes and categories.")
        except Exception:
            insights.append("‚ö† Classification unavailable.")
            insights.append("[Explainability] Classification failed due to missing or invalid data.")

        # Budget recommendations
        try:
            recs = self.budget_recommender.recommend(df)
            insights.extend(recs)
            insights.append("[Explainability] Recommendations are generated based on spending patterns and budgeting rules.")
        except Exception:
            insights.append("‚ö† Recommendations unavailable.")
            insights.append("[Explainability] Recommendation generation failed due to missing or invalid data.")

        return insights
